"""
This type stub file was generated by pyright.
"""

import asyncio
import logging
import typing
from aiogram import dispatcher
from aiogram.bot.bot import Bot
from aiogram.utils.deprecated import renamed_argument
from .filters import AbstractFilter
from .handler import Handler
from .storage import BaseStorage, FSMContext
from .. import types
from ..utils.mixins import ContextInstanceMixin, DataMixin

log = logging.getLogger(__name__)
DEFAULT_RATE_LIMIT = 0.1
class Dispatcher(DataMixin, ContextInstanceMixin):
    """
    Simple Updates dispatcher

    It will process incoming updates: messages, edited messages, channel posts, edited channel posts,
    inline queries, chosen inline results, callback queries, shipping queries, pre-checkout queries.
    """
    def __init__(self, bot: Bot, loop: typing.Optional[typing.Any]=..., storage: typing.Optional[BaseStorage]=...,
                run_tasks_by_default: bool=...,
                throttling_rate_limit: float=..., no_throttle_error: bool=...,
                filters_factory: typing.Any=...):
        ...
    
    @property
    def loop(self) -> ,:
        ...
    
    def __del__(self):
        ...
    
    async def skip_updates(self):
        """
        You can skip old incoming updates from queue.
        This method is not recommended to use if you use payments or you bot has high-load.

        :return: None
        """
        ...
    
    async def process_updates(self, updates, fast: , = ...):
        """
        Process list of updates

        :param updates:
        :param fast:
        :return:
        """
        ...
    
    async def process_update(self, update: types.Update):
        """
        Process single update object

        :param update:
        :return:
        """
        ...
    
    async def reset_webhook(self, check=...) -> bool:
        """
        Reset webhook

        :param check: check before deleting
        :return:
        """
        ...
    
    async def start_polling(self, timeout=..., relax=..., limit=..., reset_webhook=..., fast: , = ..., error_sleep: int = ...):
        """
        Start long-polling

        :param timeout:
        :param relax:
        :param limit:
        :param reset_webhook:
        :param fast:
        :return:
        """
        ...
    
    def stop_polling(self):
        """
        Break long-polling process.

        :return:
        """
        ...
    
    async def wait_closed(self):
        """
        Wait for the long-polling to close

        :return:
        """
        ...
    
    def is_polling(self):
        """
        Check if polling is enabled

        :return:
        """
        ...
    
    def register_message_handler(self, callback, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs):
        """
        Register handler for message

        .. code-block:: python3

            # This handler works only if state is None (by default).
            dp.register_message_handler(cmd_start, commands=['start', 'about'])
            dp.register_message_handler(entry_point, commands=['setup'])

            # This handler works only if current state is "first_step"
            dp.register_message_handler(step_handler_1, state="first_step")

            # If you want to handle all states by one handler, use `state="*"`.
            dp.register_message_handler(cancel_handler, commands=['cancel'], state="*")
            dp.register_message_handler(cancel_handler, lambda msg: msg.text.lower() == 'cancel', state="*")

        :param callback:
        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param custom_filters: list of custom filters
        :param kwargs:
        :param state:
        :return: decorated function
        """
        ...
    
    message_handler: Handler

    def edited_message_handler(self, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs):
        """
        Decorator for edited message handler

        You can use combination of different handlers

        .. code-block:: python3

            @dp.message_handler()
            @dp.edited_message_handler()
            async def msg_handler(message: types.Message):

        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_channel_post_handler(self, callback, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs):
        """
        Register handler for channel post

        :param callback:
        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def channel_post_handler(self, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs):
        """
        Decorator for channel post handler

        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_edited_channel_post_handler(self, callback, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs):
        """
        Register handler for edited channel post

        :param callback:
        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def edited_channel_post_handler(self, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs):
        """
        Decorator for edited channel post handler

        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param custom_filters: list of custom filters
        :param state:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_inline_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Register handler for inline query

        Example:

        .. code-block:: python3

            dp.register_inline_handler(some_inline_handler, lambda inline_query: True)

        :param callback:
        :param custom_filters: list of custom filters
        :param state:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def inline_handler(self, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Decorator for inline query handler

        Example:

        .. code-block:: python3

            @dp.inline_handler(lambda inline_query: True)
            async def some_inline_handler(inline_query: types.InlineQuery)

        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_chosen_inline_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Register handler for chosen inline query

        Example:

        .. code-block:: python3

            dp.register_chosen_inline_handler(some_chosen_inline_handler, lambda chosen_inline_query: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return:
        """
        ...
    
    def chosen_inline_handler(self, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Decorator for chosen inline query handler

        Example:

        .. code-block:: python3

            @dp.chosen_inline_handler(lambda chosen_inline_query: True)
            async def some_chosen_inline_handler(chosen_inline_query: types.ChosenInlineResult)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return:
        """
        ...
    
    def register_callback_query_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Register handler for callback query

        Example:

        .. code-block:: python3

            dp.register_callback_query_handler(some_callback_handler, lambda callback_query: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def callback_query_handler(self, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Decorator for callback query handler

        Example:

        .. code-block:: python3

            @dp.callback_query_handler(lambda callback_query: True)
            async def some_callback_handler(callback_query: types.CallbackQuery)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_shipping_query_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Register handler for shipping query

        Example:

        .. code-block:: python3

            dp.register_shipping_query_handler(some_shipping_query_handler, lambda shipping_query: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def shipping_query_handler(self, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Decorator for shipping query handler

        Example:

        .. code-block:: python3

            @dp.shipping_query_handler(lambda shipping_query: True)
            async def some_shipping_query_handler(shipping_query: types.ShippingQuery)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_pre_checkout_query_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Register handler for pre-checkout query

        Example:

        .. code-block:: python3

            dp.register_pre_checkout_query_handler(some_pre_checkout_query_handler, lambda shipping_query: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def pre_checkout_query_handler(self, *custom_filters, state=..., run_task=..., **kwargs):
        """
        Decorator for pre-checkout query handler

        Example:

        .. code-block:: python3

            @dp.pre_checkout_query_handler(lambda shipping_query: True)
            async def some_pre_checkout_query_handler(shipping_query: types.ShippingQuery)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_poll_handler(self, callback, *custom_filters, run_task=..., **kwargs):
        """
        Register handler for poll
        
        Example:

        .. code-block:: python3

            dp.register_poll_handler(some_poll_handler)

        :param callback:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def poll_handler(self, *custom_filters, run_task=..., **kwargs):
        """
        Decorator for poll handler

        Example:

        .. code-block:: python3

            @dp.poll_handler()
            async def some_poll_handler(poll: types.Poll)

        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_poll_answer_handler(self, callback, *custom_filters, run_task=..., **kwargs):
        """
        Register handler for poll_answer
        
        Example:

        .. code-block:: python3

            dp.register_poll_answer_handler(some_poll_answer_handler)

        :param callback:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def poll_answer_handler(self, *custom_filters, run_task=..., **kwargs):
        """
        Decorator for poll_answer handler

        Example:

        .. code-block:: python3

            @dp.poll_answer_handler()
            async def some_poll_answer_handler(poll_answer: types.PollAnswer)

        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_errors_handler(self, callback, *custom_filters, exception=..., run_task=..., **kwargs):
        """
        Register handler for errors

        :param callback:
        :param exception: you can make handler for specific errors type
        :param run_task: run callback in task (no wait results)
        """
        ...
    
    def errors_handler(self, *custom_filters, exception=..., run_task=..., **kwargs):
        """
        Decorator for errors handler

        :param exception: you can make handler for specific errors type
        :param run_task: run callback in task (no wait results)
        :return:
        """
        ...
    
    def current_state(self, *, chat: , = ..., user: , = ...) -> FSMContext:
        """
        Get current state for user in chat as context

        .. code-block:: python3

            with dp.current_state(chat=message.chat.id, user=message.user.id) as state:
                pass

            state = dp.current_state()
            state.set_state('my_state')

        :param chat:
        :param user:
        :return:
        """
        ...
    
    @renamed_argument(old_name='user', new_name='user_id', until_version='3.0', stacklevel=3)
    @renamed_argument(old_name='chat', new_name='chat_id', until_version='3.0', stacklevel=4)
    async def throttle(self, key, *, rate=..., user_id=..., chat_id=..., no_error=...) -> bool:
        """
        Execute throttling manager.
        Returns True if limit has not exceeded otherwise raises ThrottleError or returns False

        :param key: key in storage
        :param rate: limit (by default is equal to default rate limit)
        :param user_id: user id
        :param chat_id: chat id
        :param no_error: return boolean value instead of raising error
        :return: bool
        """
        ...
    
    @renamed_argument(old_name='user', new_name='user_id', until_version='3.0', stacklevel=3)
    @renamed_argument(old_name='chat', new_name='chat_id', until_version='3.0', stacklevel=4)
    async def check_key(self, key, chat_id=..., user_id=...):
        """
        Get information about key in bucket

        :param key:
        :param chat_id:
        :param user_id:
        :return:
        """
        ...
    
    @renamed_argument(old_name='user', new_name='user_id', until_version='3.0', stacklevel=3)
    @renamed_argument(old_name='chat', new_name='chat_id', until_version='3.0', stacklevel=4)
    async def release_key(self, key, chat_id=..., user_id=...):
        """
        Release blocked key

        :param key:
        :param chat_id:
        :param user_id:
        :return:
        """
        ...
    
    def async_task(self, func):
        """
        Execute handler as task and return None.
        Use this decorator for slow handlers (with timeouts)

        .. code-block:: python3

            @dp.message_handler(commands=['command'])
            @dp.async_task
            async def cmd_with_timeout(message: types.Message):
                await asyncio.sleep(120)
                return SendMessage(message.chat.id, 'KABOOM').reply(message)

        :param func:
        :return:
        """
        ...
    
    def throttled(self, on_throttled: , = ..., key=..., rate=..., user_id=..., chat_id=...):
        """
        Meta-decorator for throttling.
        Invokes on_throttled if the handler was throttled.

        Example:

        .. code-block:: python3

            async def handler_throttled(message: types.Message, **kwargs):
                await message.answer("Throttled!")

            @dp.throttled(handler_throttled)
            async def some_handler(message: types.Message):
                await message.answer("Didn't throttled!")

        :param on_throttled: the callable object that should be either a function or return a coroutine
        :param key: key in storage
        :param rate: limit (by default is equal to default rate limit)
        :param user_id: user id
        :param chat_id: chat id
        :return: decorator
        """
        ...
    
    def bind_filter(self, callback: ,, validator: , = ..., event_handlers: , = ..., exclude_event_handlers: , = ...):
        """
        Register filter

        :param callback: callable or subclass of :obj:`AbstractFilter`
        :param validator: custom validator.
        :param event_handlers: list of instances of :obj:`Handler`
        :param exclude_event_handlers: list of excluded event handlers (:obj:`Handler`)
        """
        ...
    
    def unbind_filter(self, callback: ,):
        """
        Unregister filter

        :param callback: callable of subclass of :obj:`AbstractFilter`
        """
        ...
    
    def setup_middleware(self, middleware):
        """
        Setup middleware

        :param middleware:
        :return:
        """
        ...
    


