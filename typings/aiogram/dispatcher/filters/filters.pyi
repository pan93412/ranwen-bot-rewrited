"""
This type stub file was generated by pyright.
"""

import abc
import typing
from ..handler import FilterObj, Handler

class FilterNotPassed(Exception):
    ...


def wrap_async(func):
    ...

def get_filter_spec(dispatcher, filter_: callable):
    ...

def get_filters_spec(dispatcher, filters: ,):
    ...

async def execute_filter(filter_: FilterObj, args):
    """
    Helper for executing filter

    :param filter_:
    :param args:
    :return:
    """
    ...

async def check_filters(filters: ,, args):
    """
    Check list of filters

    :param filters:
    :param args:
    :return:
    """
    ...

class FilterRecord:
    """
    Filters record for factory
    """
    def __init__(self, callback: ,, validator: , = ..., event_handlers: , = ..., exclude_event_handlers: , = ...) -> None:
        ...
    
    def resolve(self, dispatcher, event_handler, full_config):
        ...
    


class AbstractFilter(abc.ABC):
    """
    Abstract class for custom filters.
    """
    @classmethod
    @abc.abstractmethod
    def validate(cls, full_config: ,) -> ,:
        """
        Validate and parse config.

        This method will be called by the filters factory when you bind this filter.
        Must be overridden.

        :param full_config: dict with arguments passed to handler registrar
        :return: Current filter config
        """
        ...
    
    @abc.abstractmethod
    async def check(self, *args) -> bool:
        """
        Will be called when filters checks.

        This method must be overridden.

        :param args:
        :return:
        """
        ...
    
    async def __call__(self, *args) -> bool:
        ...
    
    def __invert__(self):
        ...
    
    def __and__(self, other):
        ...
    
    def __or__(self, other):
        ...
    


class Filter(AbstractFilter):
    """
    You can make subclasses of that class for custom filters.

    Method ``check`` must be overridden
    """
    @classmethod
    def validate(cls, full_config: ,) -> ,:
        """
        Here method ``validate`` is optional.
        If you need to use filter from filters factory you need to override this method.

        :param full_config: dict with arguments passed to handler registrar
        :return: Current filter config
        """
        ...
    


class BoundFilter(Filter):
    """
    To easily create your own filters with one parameter, you can inherit from this filter.

    You need to implement ``__init__`` method with single argument related with key attribute
    and ``check`` method where you need to implement filter logic.
    """
    key = ...
    required = ...
    default = ...
    @classmethod
    def validate(cls, full_config: ,) -> ,:
        """
        If ``cls.key`` is not :obj:`None` and that is in config returns config with that argument.

        :param full_config:
        :return:
        """
        ...
    


class _LogicFilter(Filter):
    @classmethod
    def validate(cls, full_config: ,):
        ...
    


class NotFilter(_LogicFilter):
    def __init__(self, target) -> None:
        ...
    
    async def check(self, *args):
        ...
    


class AndFilter(_LogicFilter):
    def __init__(self, *targets) -> None:
        ...
    
    async def check(self, *args):
        """
        All filters must return a positive result

        :param args:
        :return:
        """
        ...
    
    def append(self, target):
        ...
    


class OrFilter(_LogicFilter):
    def __init__(self, *targets) -> None:
        ...
    
    async def check(self, *args):
        """
        One of filters must return a positive result

        :param args:
        :return:
        """
        ...
    
    def append(self, target):
        ...
    


